#+TITLE: SELECT ROUND-UP
#+STARTUP: overview hideblocks
#+OPTIONS: toc:nil num:nil ^:nil
* README

  This notebook contains a round-up of the entire SELECT command
  pipeline in SQL. The code blocks run with SQLite, and we use a
  simple database of three different tables to explore SELECT.

  To run this notebook, which resides in GitHub and GDrive (in the
  /practice directory), you need to have SQLite installed and in the
  PATH so that Emacs can find it, and you need to have the ~/.emacs~
  file also available from GDrive, installed in Emacs' HOME directory.

* Download

  * Download ~xyz.zip~ [[https://drive.google.com/drive/folders/1_eqZil6MrybeXqhuy_8LEiz8UW9TQ1Yr?usp=sharing][from GDrive]].

  * This includes the SQLite file ~xyz.sql~ and a directory with image
    files.

* Preliminaries

  * For the presentation, I'm going to use the XMind-map from GitHub.

    #+caption: SELECT round-up
    #+attr_html: :width 600px
    [[./img/select1.png]]

  * [X] How are the commands in the mindmap ordered (from right to
    left)?

    #+begin_quote
    Answer: this is the pipeline order for ~SELECT~
    #+end_quote

* Create some tables

  * [X] Let's load some tables to play with. The file ~xyz.sql~ is
    available from [[https://drive.google.com/drive/folders/1_7g2QHnAEc_4pQki6r-KRJYGcl_mdq3Y?usp=sharing][GDrive's notebook directory]]. It contains a
    complete database dump. We load it with the SQLite command
    ~.read~, then check database and tables. There should be three,
    named ~x~, ~y~, and ~z~.

    #+name: read tables
    #+begin_src sqlite :db xyz.db :header :column :exports both :results output
      .read xyz.sql
      .database
      .tables
    #+end_src

    #+RESULTS: read tables
    : main: c:\Users\birkenkrahe\Documents\GitHub\db330\practice\xyz.db r/w
    : x  y  z

  * [ ] Challenge: if the tables already exist in ~xyz.db~ (and you
    don't have the ~IF NOT EXISTS~ clause in the ~CREATE TABLE~
    statement), you need to delete the database before loading the
    tables. But even if you do that, the ~INSERT~ commands will add to
    the existing tables. So how can you limit the import or delete
    duplicate entries?

    #+begin_quote
    ANSWER: You have to select the unique entries with ~DISTINCT~.
    #+end_quote

  * We use ~SELECT~ with the wildcard ~*~ for the column selection,
    and without conditions (i.e. conditions on row selections) to look
    at each table.

  * [ ] Print table ~x~ - one integer column and one column of strings.

    #+name: select from x
    #+begin_src sqlite :db xyz.db :header :column :exports both
      SELECT * FROM x;
    #+end_src

    #+RESULTS: select from x
    | a | b       |
    | - | ------- |
    | 1 | Alice   |
    | 2 | Bob     |
    | 3 | Charlie |
    
  * [ ] Print table ~y~ - one integer column and one column of floats.

    #+name: select from y
    #+begin_src sqlite :db xyz.db :header :column :exports both
      SELECT * FROM y;
    #+end_src

    #+RESULTS: select from y
    | c |       d |
    | - | ------- |
    | 1 | 3.14159 |
    | 1 | 2.71828 |
    | 2 | 1.61803 |

  * [ ] Print table ~y~ - two integer columns

    #+name: select from z
    #+begin_src sqlite :db xyz.db :header :column :exports both
      SELECT * FROM z;
    #+end_src

    #+RESULTS: select from z
    | a |   e |
    | - | --- |
    | 1 | 100 |
    | 1 | 150 |
    | 3 | 300 |
    | 9 | 900 |

  #+caption: Sample tables x,y,z
  #+attr_html: :width 800px
  [[./img/xyz.png]]

* Simple JOINs

  * [ ] CROSS JOIN: Since both tables had 3 rows and 2 colums, the result
    set has 9=3*3 rows and 4=2*2 columns.

    #+name: join1
    #+begin_src sqlite :db xyz.db :header :column :exports both
      SELECT * FROM x JOIN y;
    #+end_src

    #+RESULTS: join1
    | a | b       | c |       d |
    | - | ------- | - | ------- |
    | 1 | Alice   | 1 | 3.14159 |
    | 1 | Alice   | 1 | 2.71828 |
    | 1 | Alice   | 2 | 1.61803 |
    | 2 | Bob     | 1 | 3.14159 |
    | 2 | Bob     | 1 | 2.71828 |
    | 2 | Bob     | 2 | 1.61803 |
    | 3 | Charlie | 1 | 3.14159 |
    | 3 | Charlie | 1 | 2.71828 |
    | 3 | Charlie | 2 | 1.61803 |

    #+name: join2
    #+begin_src sqlite :db xyz.db :header :column :exports both
    SELECT * FROM x CROSS JOIN y;
  #+end_src

    #+name: join3
    #+begin_src sqlite :db xyz.db :header :column :exports both
    SELECT * FROM x,y;
    #+end_src

* JOIN ... ON

  * [ ] INNER JOIN: Remember the zipper principle - identify 2 columns to
    zip xtogether. This identification follows after the ~ON~ keyword.

    #+name: join4
    #+begin_src sqlite :db xyz.db :header :column :exports both
      SELECT * FROM x JOIN y ON a = c;
    #+end_src

    #+RESULTS: join4
    | a | b     | c |       d |
    | - | ----- | - | ------- |
    | 1 | Alice | 1 | 2.71828 |
    | 1 | Alice | 1 | 3.14159 |
    | 2 | Bob   | 2 | 1.61803 |

    - Compare with the CROSS JOIN before. This time, Only those
      columns that satisfy the condition ~a=c~ are included in [[join4]]

  * [ ] What if we want to ~JOIN~ tables ~x~ and ~z~? They both have a
    column named ~a~. We now need to qualify the selection with ~.~

    #+name: join5
    #+begin_src sqlite :db xyz.db :header :column :exports both
      SELECT * FROM x JOIN z ON x.a = z.a;
    #+end_src

    #+RESULTS: join5
    | a | b       | a |   e |
    | - | ------- | - | --- |
    | 1 | Alice   | 1 | 100 |
    | 1 | Alice   | 1 | 150 |
    | 3 | Charlie | 3 | 300 |

  * [ ] You can resolve column name confusions (same column name in
    different tables) by using aliases. Run the previous command [[join5]]
    again, but alias ~x~ as ~t_x~ and ~z~ as ~t_z~.

    #+name: join7
    #+begin_src sqlite :db xyz.db :header :column :nullvalue [NULL]
      SELECT * FROM x AS t_x JOIN z AS t_z ON t_x.a = t_z.a;
    #+end_src

    #+RESULTS: join7
    | a | b       | a |   e |
    | - | ------- | - | --- |
    | 1 | Alice   | 1 | 100 |
    | 1 | Alice   | 1 | 150 |
    | 3 | Charlie | 3 | 300 |

  * [ ] There are five (!) more ~JOIN~ commands:
    - ~LEFT OUTER JOIN~ will also include not matched items
    - ~COMPOUND JOIN~ joins multiple tables

    #+name: join6
    #+begin_src sqlite :db xyz.db :header :column :nullvalue [NULL]
      SELECT * FROM x JOIN y ON x.a=y.c LEFT OUTER JOIN z ON y.c=z.a;
    #+end_src

    #+RESULTS: join6
    | a | b     | c |       d |      a |      e |
    | - | ----- | - | ------- | ------ | ------ |
    | 1 | Alice | 1 | 2.71828 |      1 |    100 |
    | 1 | Alice | 1 | 2.71828 |      1 |    150 |
    | 1 | Alice | 1 | 3.14159 |      1 |    100 |
    | 1 | Alice | 1 | 3.14159 |      1 |    150 |
    | 2 | Bob   | 2 | 1.61803 | [NULL] | [NULL] |

    * Work through this example until you reall understand what this
      multiple join = INNER JOIN + LEFT JOIN does!

* WHERE examples
    
  * [ ] Print a row: the value ~Alice~ for the attribute ~x.b~.

    #+name: row
    #+begin_src sqlite :db xyz.db :header :column
      SELECT * FROM x WHERE x.b = 'Alice';
    #+end_src

    #+RESULTS: row
    | a | b     |
    | - | ----- |
    | 1 | Alice |

  * [ ] Print a range of values, for 1.0 < d < 3.0.
    
    #+name: between
    #+begin_src sqlite :db xyz.db :header :column
      SELECT * FROM y WHERE y.d BETWEEN 1.0 AND 3.0;
    #+end_src

    #+RESULTS: between
    | c |       d |
    | - | ------- |
    | 1 | 2.71828 |
    | 2 | 1.61803 |

  * [ ] Print columns c, d and a column for the sum of c+d with the
    condition that the sum is smaller than 4.

    #+name: sum
    #+begin_src sqlite :db xyz.db :header :column
      SELECT c, d, c+d AS sum FROM y WHERE sum < 4.0
    #+end_src

    #+RESULTS: sum
    | c |       d |     sum |
    | - | ------- | ------- |
    | 1 | 2.71828 | 3.71828 |
    | 2 | 1.61803 | 3.61803 |

  * [ ] The next block [[sum1]] uses foods.db to select a range of values
    with wildcards. Here, * instead of % would also work (try it).

    #+name: sum1
    #+begin_src sqlite :db foods.db
      Select name from foods where name between 'Ta%' AND 'Ti%';
    #+end_src

    #+RESULTS: sum1
    | Tarragon         |
    | Tea              |
    | Three Musketeers |
    | Tamale           |
    | Tamales          |

* GROUP BY Examples

  * [ ] Group table z by the column z.a. Can
    you guess how many rows are going to be printed?

    #+name: groupBy
    #+begin_src sqlite :db xyz.db :header :column
	SELECT a FROM z GROUP BY z.a;
    #+end_src    

    #+RESULTS: groupBy
    | a |
    | - |
    | 1 |
    | 3 |
    | 9 |

  * [ ] Print the number of rows next to every value of z.a. Call this
    new column 'count'n.

    #+name: groupBy1
    #+begin_src sqlite :db xyz.db :header :column
	SELECT a, COUNT(a) AS count FROM z GROUP BY z.a;
    #+end_src    

    #+RESULTS: groupBy1
    | a | count |
    | - | ----- |
    | 1 |     2 |
    | 3 |     1 |
    | 9 |     1 |

  * [ ] Run [[groupBy]] again (group by z.a) but now also print out the
    sum of all the z.e values in each group. Call the new column
    'TOTAL'.

    #+name: groupBy2
    #+begin_src sqlite :db xyz.db :header :column
	SELECT a, sum(e) AS TOTAL FROM z GROUP BY z.a;
    #+end_src    

    #+RESULTS: groupBy2
    | a | TOTAL |
    | - | ----- |
    | 1 |   250 |
    | 3 |   300 |
    | 9 |   900 |
    
  * [ ] Run [[groupBy]] again (group by z.a) but now also compute
    - the sum(e) as SUM
    - the count(e) as TOTAL
    - the average as AGG computed with sum and count
    - the average as AVG computed with the aggregate function

    #+name: groupBy3
    #+begin_src sqlite :db xyz.db :header :column
	SELECT a, sum(e) as SUM, count(e) as TOTAL, sum(e)/count(e) AS AGG, avg(e) AS AVG FROM z GROUP BY z.a;
    #+end_src    

    #+RESULTS: groupBy3
    | a | SUM | TOTAL | AGG |   AVG |
    | - | --- | ----- | --- | ----- |
    | 1 | 250 |     2 | 125 | 125.0 |
    | 3 | 300 |     1 | 300 | 300.0 |
    | 9 | 900 |     1 | 900 | 900.0 |
    
  * [ ] A HAVING clause can be used to filter rows based off the
    results of the sum() aggregation. Run the block [[having]].

    #+name: having
    #+begin_src sqlite :db xyz.db :header :column
	SELECT a, sum(e) AS TOTAL FROM z GROUP BY z.a HAVING total > 500;
    #+end_src    

    #+RESULTS: having
    | a | TOTAL |
    | - | ----- |
    | 9 | 900   |

* ORDER BY examples

  * [ ] Order table y by the numbers in y.d, and print all columns.

    #+name: orderBy
    #+begin_src sqlite :db xyz.db :header :column
	SELECT * FROM y ORDER BY d;
    #+end_src    

    #+RESULTS: orderBy
    | c |       d |
    | - | ------- |
    | 2 | 1.61803 |
    | 1 | 2.71828 |
    | 1 | 3.14159 |
    
  * [ ] LIMIT and OFFSET
    
    
